# GLaDOS

GLaDOS isn’t just a Lisp environment — it’s a statement.  
Built in Haskell, GLaDOS reimagines what it means to *understand* a language rather than simply *use* it.  
What began as a student experiment evolved into a reflection on design minimalism, readability, and the art of compiling thought into action.  

Here, Lisp meets philosophy: a language about languages, distilled to its essence.  

---

##  What you get

GLaDOS offers more than a compiler — it offers a perspective.  
Each layer of the toolchain is designed to be *seen, understood, and questioned*.  

- A **transparent compiler pipeline** (parser → macros → desugaring → SSA-like lowering → bytecode), deliberately structured so every transformation can be followed like a story.  
- A **stack-based virtual machine** that embraces *tail-call optimisation* and *closures*, translating mathematical elegance into runtime precision.  
- A **minimal yet expressive standard library**, because power doesn’t need excess.  
- A **complete ecosystem**, built to be hacked, explored, and broken — then understood again.  
- A continuous integration flow that treats every commit as an experiment in stability.  

> GLaDOS isn’t only meant to run code — it’s meant to help you *see* code differently.  

---

##  Quick tour

\```bash
# Build the executable (uses stack under the hood)
make

# Run a Lisp file
./glados examples/factorial_test.lisp

# Peek at the generated bytecode
./glados --disasm examples/factorial_test.lisp

# Dump raw bytecode instructions
./glados --bytecode examples/factorial_test.lisp

# Run the Haskell unit tests locally
stack test
\```

Behind these simple commands lies a philosophy of transparency:  
You don’t just *use* the toolchain — you *witness* every step of thought, from syntax to execution.  

Each instruction emitted by the compiler is a visible echo of intent.  
Each test, an act of discipline.  
Each build, a conversation between human reasoning and machine precision.  

---

##  Learn the project

Understanding GLaDOS is like exploring the anatomy of an idea.  

- `docs/README.md` — the map to the world  
- `docs/ARCHITECTURE.md` — the anatomy of clarity  
- `docs/LANGUAGE_GUIDE.md` — the manifesto of syntax  
- `docs/INSTRUCTIONS.md` — a deep dive into the machine’s inner voice  
- `docs/DEVELOPMENT.md` — the art of iteration and failure  

Every document is a piece of philosophy wrapped in code,  
an invitation to see simplicity not as a constraint — but as a form of purity.  

---

##  Repository layout

\```
.
├── app/                 Entry point — where ideas meet execution
├── docs/                The living memory of the project
├── examples/            Proofs of concept, thoughts turned into syntax
├── scripts/             Small tools that keep the ecosystem alive
├── src/                 The beating heart: compiler, runtime, builtins
├── test/                Where assumptions go to be challenged
└── Makefile             Because simplicity is reproducibility
\```

Key components worth exploring:
- `src/Compiler.hs` — where structure becomes meaning  
- `src/CodeGen.hs` — translating abstract thought into concrete bytecode  
- `src/VM.hs` — the living loop; execution as rhythm  
- `src/Builtins.hs` — the minimal vocabulary of an idea  

> Every file in this tree tells part of the story: how humans model order inside chaos.  

---

##  Current status

GLaDOS today stands as a paradox:  
a small tool with a big question — *how little do we need to understand everything?*  

- Tail-call optimisation flows naturally, not as a feature but as a belief in recursion done right.  
- Continuous integration watches over each push like a silent guardian of discipline.  
- The known limitations are not flaws, but frontiers; boundaries that invite exploration.  

GLaDOS doesn’t pretend to be perfect — it just insists on being *understandable*.  

---

##  License

Released under the **MIT Licence**,  
because ideas should be free — both to share and to evolve.  

GLaDOS is not a product. It’s a playground for thought,  
a dialogue between Lisp’s timeless elegance and Haskell’s purity of expression.  

> *“To write a compiler is to teach a machine how to think —  
but to design one well is to remember how we do.”*  
