---
title: Getting Started
description: Getting Started with Topineur
icon: Album
---
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Terminal } from 'lucide-react'

## Overview

Welcome to **Topineur**! This guide will walk you through everything you need to start building with our language.

## Installation

<Steps>
  <Step>
Download the compiler :

```bash tab="<Terminal /> Using curl"
# On Linux/macOS
curl -sSL https://topineur.org/install.sh | bash
```

```bash tab="Using wget"
# On Linux/macOS
wget -qO- https://topineur.org/install.sh | bash
```
  </Step>
  <Step>
Verify installation :

```bash title="Bash"
glados --version
```
  </Step>
</Steps>

## Your first Topineur Program

Create a new file called `main.top` and add the following code:

```topineur title="main.top"
|- Main function
package main

def main(): Int {
  println("Hello, Topineur!")
}
```

Run your program using:

```bash
glados main.top
```

## Basic Syntax

### Packages and Imports

#### Modules [!toc]

Declare a module's package at the top of a file with the `package` keyword. For example:

```topineur
package lib.hello
```

Conventions :
- Module paths map to filesystem paths. Each `.` is like a `/`.
  - `lib.hello` -> `lib/hello.top`

#### Imports [!toc]

Use `import` with the module path to bring a module into scope. Examples:

```topineur
import std.core
import std.collections.list
import std.string
```

Conventions :
- Use dot notation to import nested modules (e.g., `std.collections.list`).
- `std` is the standard library prefix.


### Variables and Types

In **Topineur**, you can use different types. For example :

```topineur
let name: String = "World"      |- String Variable
let age: Int = 25               |- Integer Variable
let height: Float = 1.75        |- Float Variable
let isActive: Bool = true       |- Boolean Variable
```

### Functions

Functions in Topineur are declared using the `def` keyword, and to return use the `top` keyword :

```topineur
|- Define a function add
def add(a: Int, b: Int): Int {
    top a + b
}

|- Concatenates strings
def print_variable(variable: String): Void {
    println("Variable is " ++ variable ++ "!")
}

|- Call the other functions
def main(): Int {
  let variable: Int = add(10, 5)

  print_variable(show(variable))
}
```


### Control Flow

Topineur supports standard control flow structures:

<Callout title="If Rules" type="warning">
  Control-flow blocks must be complete: you can't write an `if` without a matching `else`.
</Callout>

```topineur
|- If statements
if score > 100 then println("High score!")
else if score > 50 then println("Good effort!")
else println("Keep trying!")

|- Loops
|- While loops
while i > 0 do
    println("Number is " ++ show(i))
    i = i + 1
end

|- For loops
for i in 1..5 do
    println("Number is " ++ show(i))
end
```

### Objects

Objects allow you to organize data and behavior together. Here's how we define an object.

<Callout title="Indentation and Syntax rules" type="warning">
  - Keep indentation consistent. If you use 2 spaces, stick with 2 spaces throughout the file.
  - Indentation matters for readability and for some tooling.
</Callout>

```topineur
|- Define an object Person
object type Person {
  name: String = "Laurent"
  age: Int

  |- Introduce the person
  def introduce(): Void {
    println("Hi, I'm " ++ self.name ++ " and I'm " ++ show(self.age) ++ " years old.")
  }

  |- Method with logic
  def is_adult(): Bool {
    if self.age < 18 then top True
    else top False
  }
}

|- Define the Object globally
let laurent = Person {
  name = Laurent,
  age = 20
}

|- Use the Object
def main(): Int {
    laurent.introduce()
    if laurent.is_adult() then top 0
    else top 1
}
```

### Lists and Tuples

Lists and tuples serve are available in this language. This is how to use them:

#### Lists

Create lists with a type annotation and square brackets.

```topineur
package main
import std.collections.list

|- Main function
def main(): Int {
  |- Create a list of string
  let glados: List[Int] = [1, 2, 3, 4]

  |- Length and indexing
  let g: Int = list_length(glados)
  let first: Int = glados[0]
}
```

#### Tuples

Create tuples like you would create a **list**.

```topineur
package main

|- Main function
def main(): Int {
  |- Define a tuple
  let coffee_guys: Tuple[String] = ("axel", "sylas")
}
```

### Anonymous functions

Anonymous function are a one-line function. You can use it to create inline functions without declaring a named function. They are useful for short operations.

#### Syntax [!toc]

```topineur
fun ((<param1>: <Type1>, <param2>: <Type2>, ...): <ReturnType> -> <expression>)
```

#### Example [!toc]

Use the `fun` expression to create an anonymous function and assign it to a variable, then call it from `main`.

```topineur
package main

|- Main function
def main(): Int {
  |- Define a anonymous fnction
  fun((a: Int, b: Int): Int -> top a + b)

  let sum: Int = add(3, 4)
  println("3 + 4 = " ++ show(sum))
  top 0
}
```

### Decorateur

A decorator is a function that can take another function as an argument and returns a new function, but this will be available later. For now it is used for memoization.

Usage :

```topineur
package main

@cache
def fib(n: Int): Int {
  if n <= 1 then top n
  else top fib(n - 1) + fib(n - 2)
}

def main(): Int {
  let f: Int = fib(5)
  println("fib(5) = " ++ show(f))
  top 0
}
```

## Next Steps

Now that you've got the basics, you can:

1. Explore the [Language Guide](/docs/language/guide) for detailed documentation
2. Try the [Interactive Tutorial](/docs/language/tutorial)
3. Check out [Example Projects](/docs/language/examples)
