---
title: Import System
description: Manages module dependencies and code inclusion.
icon: Import
---

## Topineur import system

The Topineur language provides a compile-time import system. Imports are resolved and compiled during the compilation phase, the compiler then combines the resulting code objects into the program that the VM executes.

### Import

Topineur use regular package. Regular package is typically implemented as a `.top` file. When a regular package is imported, the functions inside of it a implicitly executed.

For example, the following system define 3 different packages:

<Files>
  <Folder name="/" defaultOpen>
    <File name="one.top" />
    <File name="two.top" />
    <File name="three.top" />
  </Folder>
</Files>

When importing a package like `foo.bar.baz` is resolved to a path by splitting the module name on `.` and joining the components, then appending the `.top`. The path to the file should look like this :

<Files>
  <Folder name="foo" defaultOpen>
    <Folder name="bar" defaultOpen>
      <File
        name="baz.mdx"
        className="!text-fd-primary !bg-fd-primary/10"
      />
    </Folder>
  </Folder>
</Files>

### Package declarations

Topineur supports package declarations which name the current package and group its top-level definitions. In the compiler AST this is represented as `EPackage Name` and is recognized alongside `EImport` when the compiler extracts program structure.

A package declaration is optional but recommended for larger projects where you want to place modules in a clear namespace. A common convention is to put a package declaration at the top of a `.top` file, followed by imports and definitions:

```topineur title="example.top"
|- Example
package my.project.sub

import std.list

def main(): Int {
    println("Hello from example")
}
```

Notes about package semantics and resolution:

- The package name is purely a compile-time namespace used by the compiler to organize and resolve imports; it does not, by itself, change runtime behavior of values defined in the module.
- Module filenames are determined by splitting a module name on `.` and joining the segments as path components, then appending the `.top` extension (for example, `my.project.sub` â†’ `my/project/sub.top`).
- When resolving an import the compiler searches the importing file's directory first, then the directories listed in `CompilerConfig.cfgModulePaths` (by default this includes `stdlib`). This makes local project modules override the stdlib when names collide.
